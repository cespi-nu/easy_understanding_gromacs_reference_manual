 # Gromacsの公式ドキュメントのReference Manualを読み砕いて理解するためのノート
 ## #1 Introduction
**230406-230410 Yoda**
参照: [Reference Manual](https://manual.gromacs.org/current/reference-manual/introduction.html)
***
 ※始めに
 このマニュアルではGromacsが行う計算処理のバックグラウンドが説明されており、その過程で量子力学が何度も顔を出してくる。量子力学とは我々の世界で見られるマクロな物体の動きを記述する古典力学に対して、原子や素粒子といったミクロな物体のふるまいを記述することを目的として発展してきた分野である。マクロな物体の動きを記述するためには古典力学で十分であるが、ミクロな物体には古典力学では説明できない(矛盾してしまう)性質を多く持っている。筆者はYoutubeでヨビノリの量子力学の講座を少しかじった程度であるが、量子に見られる特異なふるまいについて数式を用いながらかみ砕いて解説しているので、量子力学の知識に疎い人で興味のある人は視聴を勧める。
 [ヨビノリの量子力学講座](https://yobinori.jp/video/quantum-mechanics.html)


 #### Computational Chemistry and Molecular Modeling
 Gromacsは分子動力学シミュレーション(molecular dynamics simulation, MD)やエネルギー最小化(energy minimization)を行うためのエンジンで、計算化学(computational chemisty)と分子モデリング(molecular modeling)の技術を駆使して分子の巨視的なふるまい(macroscopic property)を計算することができる。

 マクロスケールでの物性を決めるパラメーターはこれらの2種類に大別される。

1. 阻害剤の結合定数や系の平均エネルギーなどの静的平衡特性(static equilibrium property)
2. 液体の粘性や膜の拡散運動などの動的非平衡特性(dynamic or non-equilibrium property)  

 解決したい問題の内容や現在の技術水準によって適用する手法は異なる。系の複雑度や計算する時間の長さによっては実験に基づいたパラメーターや理論ではなく、経験的なパラメーターに置き換えたり一部で近似計算したりといった工夫で計算資源と折り合いをつけなければならない。

 そしてマクロスケールでの物性は常に系全体の平均パラメーターに依存するが、これによって分子モデリングではこれらのような重要な特性がある。

- たとえ構造全体のエネルギーが最小となる分子構造を得られたとしても、その1つの構造だけではマクロスケールの物性を説明することはできない。マクロスケールの物性を説明するためには、そのマクロスケールの系を代表するような計算系(ensemble)を設定し、分子構造の安定性やリガンドの結合定数、相平衡など様々な条件を考慮して計算を行わなければならない。
- 分子シミュレーションは原理的には構造や分子の動きを詳細に説明できるが、その構造や動きは科学的な関心のある部分とは関係ないことがよくある。自分の関心に干渉しない部分に関しては統計力学と呼ばれる分野の知識で理論を簡略化することができることがある。統計力学はいくつかの原子をまとめてグループ化し統計的な処理ができる集団にすることで確率論などから計算を簡略化するフレームワークを提供してくれる。

 適切な平衡状態の計算系(マクロスケールの系の物性を保持した代表系、representative ensemble)を生成する手法としては以下の2つが挙げられる。

1. モンテカルロ法 / モンテカルロシミュレーション
2. 分子動力学シミュレーション (MD simulation)

 そして、非平衡な系を取り扱う場合やダイナミクスを解析したい場合にはMDのみが適切な手法となる。モンテカルロ法はMDに比べてシンプルではあるが、MDの法が普遍的で統計的な有意性も高い。
 MDを行う上では初期状態にエネルギーを最小化したものを用いるべきである。これは初期状態を平衡状態に近づけることで計算時に過度な力がかかるのを防ぐほか、構造及びポテンシャルエネルギーの熱ノイズを低減するためで、シミュレーションで得られる「スナップショット」の比較をやりやすくする。

#### Molecular Dynamics Simulations
 MDはN個の相互作用する原子についてニュートンの運動方程式を解くことで原子の動きを計算する。
$$m_i\frac{\partial^2 r_i}{\partial t^2} = F_i, i=1...N. \tag{1}$$
 ※公式ドキュメントには上の式が仰々しく書かれているが、要は高校物理で習うma=Fである。
 (1)式における力の総和$F_i$はポテンシャルエネルギーの関数$V(r_1,r_2,...,r_N)$を用いて次のように表される。
 $$F_i=-\frac{\partial V}{\partial r_i} \tag{2}$$
 ※これも高校物理における、ポテンシャルエネルギーの定義である。

 MDではこの計算を時々温度や圧力を調節しながら微小時間のステップで繰り返し、一定時間ごとに原子の座標を記録する。これによって記録された原子の座標から原子の軌跡(trajectory)を見たり構造全体の変化を解析することで分子のマクロスケールにおける特性を理解することができるのだ。
 ここらで一度MDの限界について考えてみよう。MDが行っている近似の方法などを知ってMDの限界を理解しておくことで、今後MDの結果を見る際にそれが実際に妥当性、正確性を評価できるようになろう。

**MDは古典力学に基づいている**
 MDはニュートンの運動方程式で原子の動きを説明するが、系の温度や原子の種類によっては量子的なふるまいが起こることがある。例えばプロトンは量子的にふるまうことが多く、水素結合で形成されたポテンシャルを通り抜ける(トンネル効果)ことがある。また、結合している原子同士は常に共鳴して振動しているが、この周波数によっては古典力学では正確にシミュレーションができないことが考えられる。古典的な統計力学における調和振動子(classical harmonic oscillator、ばねのように振動運動するもの)の共振周波数($\nu$)から1cmあたりの波の数($\sigma=1/\lambda=\nu/c$、なお、$h\nu=k_BT$)を考えたときに、常温(300K)で200cm$^{-1}$に近い、あるいはその値を超えるような場合は、実際の量子振動子(quantum harmonic oscillator)の振る舞いと大きく異なる計算結果となってしまう。実質的には$\sigma\geqq$100cm$^{-1}$を超えたあたりからその計算は疑わしくなる。そして、以下の[表1](#table1)に示すように、ほとんどの共有結合/水素結合している分子同士に起こる調和振動で実際に古典力学が通用しないという問題がある。
 ※ 何がどうなるからこの数字が出てきているのかという原理的なところは理解していないがどうやら結構(appreciably)違うらしい。

<a id="table1"></a>
**表1. 共有結合/水素結合している分子同士の調和運動の種類と1cmあたりの波の数**
| 結合の種類         | 振動の種類 | 波の数 cm$^{-1} |
| :-----------: | :---: | :----------: |
| C-H, O-H, N-H | 伸縮    | 3000-3500    |
| C=C, C=O      | 伸縮    | 1700-2000    |
| HOH           | はさみ振動    | 1600         |
| C-C           | 伸縮    | 1400-1600    |
| H$_2$CX       | 横揺れ振動   | 1000-1500    |
| CCC           | はさみ振動    | 800-1000     |
| O-H…O         | 秤動    | 400-700      |
| O-H…O         | 伸縮    | 50-200       |

<table>
  <tr>
    <td style="text-align: center">伸縮</td>
    <td style="text-align: center">はさみ振動</td>
  </tr>
  <tr>
    <td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Molecular_vibration"><img src="https://upload.wikimedia.org/wikipedia/commons/0/0c/Asymmetrical_stretching.gif" alt="stretch" width="50%"></a></td>
    <td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Molecular_vibration"><img src="https://upload.wikimedia.org/wikipedia/commons/6/60/Scissoring.gif" alt="scissor" width="50%"></a></td>
  </tr>
  <tr>
    <td style="text-align: center">横揺れ振動</td>
    <td style="text-align: center">秤動</td>
  </tr>
  <tr>
    <td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Libration_(molecule)"><img src="https://upload.wikimedia.org/wikipedia/commons/1/14/Modo_rotacao.gif" alt="rock" width="50%"></a></td>
    <td style="text-align: center"><a href="https://en.wikipedia.org/wiki/Molecular_vibration"><img src="https://upload.wikimedia.org/wikipedia/commons/3/3a/Libration.gif" alt="libration" width="50%"></a></td>
  </tr>
</table>

分子の振動の種類は[こちら](https://sekigin.jp/science/chem/chem_06_04_02.html)のページにあるイラストがわかりやすいだろう。
秤動運動のみ掲載されていなかったため、[こちら](https://en.wikipedia.org/wiki/Libration_(molecule))を参照してほしい。

 このような問題に対して実際に量子力学に基づいた計算を行わずとも次の2つの方法で対処することができる。
 1. 量子振動子は基底状態で$\frac{1}{2}h\nu$のエネルギー(zero-point energy)をもっているのに対して、古典的な調和振動子は過剰なエネルギーを吸収してしまう。そのため、調和振動子を計算上で扱う際に合計の内部エネルギー($U$)と熱容量($C_V$)、そして、計算しているのであれば、エントロピー($S$)や自由エネルギー($A$または$G$)を補正する必要がある。
※ 正直に言ってここの補正は全く理解していない。マニュアル本文の法には補正の式が載っているし、[参考文献](https://vuquangnguyen2016.files.wordpress.com/2017/12/339279795-donald-a-mcquarrie-statistical-mechanics-bookzz-org.pdf)も明示しているので詳しく知りたい人はそちらを参照してほしい。  

 1. 結合や結合角に対して運動方程式上で制約(constraints)をかけることで実際の量子振動子の動きをより再現することができる。実際には実用的にも、共振周波数が高いものを除くことでアルゴリズムとしてより時間ステップが大きい系を扱えるようになるというメリットもある。
 実際にGromacsは方法2に対応しており、よりリアルな運動を計算する点と計算資源を節約する点で欠かすことのできないオプションとして機能している。

**電子は基底状態をとる**
 MDでは常に保存力場のみを用いており、電子の運動は考慮していない。すなわち、電子は常に基底状態を保ち続けているという条件で計算を行う。もちろんこの系では電子の移動や励起を取り扱うことはできないため化学反応をまともに扱うことができないが、大抵の場合では問題がなく、他にもこのような実装にした理由がある。

**力場は近似的**
 力場とは環境にかかっている力のことで、ユーザーが調整できるパラメーターである。しかし力場の設定には制限がある。Gromacsにおける力場については[4章](https://manual.gromacs.org/current/reference-manual/functions/functions.html)で詳しく説明されているが、現在のバージョンでは長距離クーロン力を除いてpair-additiveであり、分極性は組み込まれておらず、共有結合のfine-tuningもしない。そのためいくつかの制約は組み込む必要があるが、水溶液中の高分子に対してはかなり信頼のおける力場である。

**力場はpair-additive**
 Gromacsにおいて力場は非共有結合性の力のみによって構成される。2原子間の極性相互作用などを含めて、有効とされる原子のペアにおける非共有結合性の力が平均化されて力場計算に組み込まれる。すなわち、共有結合による相互作用は力場計算においては不純物である。実際にこのような計算手法はある程度有効だが、原子内の分極を無視していることによって誘電率を考慮できない問題がある。この問題は次のような手法で部分的に軽減している。
※ ここの本文わかりづらすぎなので勝手に解釈して意訳が多め。間違ってるかも。

**相互作用距離のフィルター**
 現行のGromacsではあらゆるLennard-Jones相互作用、そして時にはクーロン相互作用においてもカットオフ半径を設定している。Gromacsにおいてはボックスサイズの半分以上の距離の相互作用は計算しないことになっている。しかしそれでも系によっては距離が非常に長くなってしまうし、荷電粒子がある系などではカットオフ境界で電荷が蓄積するなどおかしな挙動が起こり得るので、そのような系を扱う際はPME(Particle Mesh Ewald)などの長距離間相互作用を考慮しているアルゴリズムを採用すべきである。

**境界が不自然**
 MDは系のサイズが小さいため境界と接する粒子の割合が大きい。また、系が小さいことは系が内部情報に強く依存することにも繋がる。これらを回避するためにMDでは系に周期性をもたせるが、それでも不自然になってしまう場合がある。系のサイズの影響は常に注視するべきである。

 #### Energy Minimization and Search Methods
 (高)分子の系においてポテンシャルエネルギーのグラフは複雑で、時には多次元の超曲面にもなる。ポテンシャルエネルギーはグローバルミニマム(global minimum)とも呼べる最小値を取るほかにも局所的な極小値(local minima)が多数存在している。ヘッセ行列(Hessian matrix)<a id="Hessian"></a><sup>[※1](#Hessian_description
 )</sup>はポテンシャルエネルギーを与える関数に対して二次の偏微分導関数を要素にもつ行列で、その固有値によって極小値周辺の環境を知ることができるためポテンシャルエネルギーの地形を把握するのに使われる。
 ポテンシャルエネルギーの地形全体を把握すれば構造変化や自由エネルギーについてのダイナミクスが説明できるが、地形が膨大で複雑であるがゆえに完全に地形をサンプリングすることは不可能である。特に最小値を実用的な時間内に決定することを補償できるようなアルゴリズムは未だ存在しない。Gromacsにおいてはある地点のポテンシャルエネルギーから最も勾配が急な方向にひたすら落ちていき極小値を見つける手法を採用しており、これは必ずしも最小値を見つける手法ではないことは理解しておくべきである。最小値を求めるための工夫の方法はいくつかあるものの、Gromacsの標準的なメソッドではないためここでは省く。
※本文ではいくつか例を挙げて紹介しているので興味があれば[本文](https://manual.gromacs.org/current/reference-manual/introduction.html#energy-minimization-and-search-methods)を参照してほしい。

 エネルギー最小化の方法としては3種類の方法が挙げられる。

1. ポテンシャルエネルギーの関数を評価する方法
2. ポテンシャルエネルギーの関数の導関数を利用する方法
3. ポテンシャルエネルギーの関数の二次導関数まで利用する方法

 方法1はあまりにも愚かで話にならない。方法2は導関数の情報からポテンシャルエネルギーの坂を急な方向にひたすら転がっていく手法で、ステップごとに進む距離(ステップサイズ)をうまく調整しないと極小値から遠いところでもヨチヨチ進んだりゴールである極小値を通り過ぎて坂を駆け上がるという問題がある。一方で方法3は二次導関数の情報からステップサイズを調整しやすいため極小値に向かって効率よく進めるメリットがあるが、N個の粒子からなる系では3N×3Nというクソデカ行列をこねくり回す必要があるため計算資源やコンピューターの記憶容量的な観点から使えたものではない。
 Gromacsは実際に方法2に属する最急降下法(勾配降下法、(steepest) gradient descent method)<a id="grad_descent"></a><sup>[※2](#grad_descent_description)</sup>を採用している。最小値探索におけるステップサイズは、探索を高速かするものの極小値を超えて坂を駆け上がらないように実装している。しかしこの手法では極小値付近に近づくのが早い反面、極小値付近ではあまり効果的な動きが期待できない。また、Gromacsは記憶制限BFGS法(Limited-memory BFGS method, L-BFGS method)もサポートしており、場合によっては計算を効率的にできるだろう。

 <a id="Hessian_description"></a>
 [※1: ヘッセ行列](#Hessian)
 ヘッセ行列の理解をするために　[このサイト](https://math-fun.net/20210121/9410/)を参考にした。図もここから引用する。
 ヘッセ行列(Hessian matrix)は多変数関数において各2変数での偏導関数を要素にもつ行列である。すなわちこのような行列だ。
 ポテンシャルエネルギーを与える関数$V(x_1, x_2, ... , x_n)$について
$$H(x)=\bigg( \frac{\partial ^2V}{\partial x_i \partial x_j}(x) \bigg)　\tag{3}$$
 よりかみ砕くなら、$V(x_1, x_2)$として、
$$
H(x)=
\begin{pmatrix}
\frac{\partial^2V}{\partial x_1^2} & \frac{\partial}{\partial x_1 } (\frac{\partial V}{\partial x_2}) \\
\frac{\partial}{\partial x_2 } (\frac{\partial V}{\partial x_1}) & \frac{\partial ^2V}{\partial x_2^2} \\
\end{pmatrix}
\tag{4}
$$
 という形で、要は$i$行$j$列では$V(x)$を変数$x_i$と変数$x_j$で偏微分した偏導関数が要素となる行列である。
 多変数関数$V(x)$における極値(今回の場合で言うと極小値)の探し方を考えてみる。
 考えることは1変数関数の時と同じで一般に$V(x)$を全微分(偏微分ではない)した際に値が0になることがまず1つ目の条件である。全微分とは偏微分とは異なり、微分のための極限を取る際に偏微分ではその軸上で両方から近づく(1変数関数の時を思い出してほしい。微分の際はxの+側と-側の両方から近づいたときの値が同じでなければならなかった。)のに対し、全微分ではあらゆる方向から近づいて微分する操作だと考えてほしい。すなわち、(1変数関数の時と同じだが、)平たく言えば関数のグラフの接面が水平であるということである。このような点を専門には臨界点(critical point)や停留点(stationary point)というらしい。
 2つ目の条件も1変数関数の時と発想は同じである。考えるべきは臨界点における2階偏導関数の値で、その値によって極大点、極小点、そして鞍点の3種類がある。
 極大点、極小点は想像の通りで、(今回は極小点$p$を考えるが、)$p$の周囲は**あらゆる方向で**より高い値をとっている。
![極小点の例](https://math-fun.net/wp-content/uploads/2020/02/000484.jpg)
 一方で、臨界点であっても極値をとらない点である臨界点は鞍点と呼ばれる。1変数関数でも、たとえば関数$f(x)=x^3$ではx=0において1次導関数は値が0であるものの極値ではなかった(変曲点)。これと同じで、多変数関数でも臨界点が必ずしも極値を取るとは限らない。このような点を、馬に乗る際などに使用する鞍になぞらえて鞍点(saddle point)と言う。
![鞍点の例](https://math-fun.net/wp-content/uploads/2020/02/000485.jpg)
 これらの見分け方だが、点$p$周りの2階偏導関数を**あらゆる方向で**計算し、(極小値は)正値になっていなければならない。この計算方法を提供するのがヘッセ行列である。ヘッセ行列の行列式を変形していくとポテンシャルエネルギーを与える関数のテイラー展開による二次近似になり、この行列式がポテンシャルエネルギーの臨界点周りの断面を表現するパラメーターを与えるのだが、このパラメーターの性質からその臨界点においてヘッセ行列の行列式の値が正であれば極点、負であれば鞍点になるということが証明されている。
 詳しい証明は[このサイト](https://qiita.com/IshitaTakeshi/items/c7b0db1c73d65f9707ea)が易しく手順を解説しているため興味がある人は参考にするとよい。

<a id="grad_descent_description"></a>
 [※2: 最急降下法](#grad_descent)
 最急降下法は複雑な関数の最小値探索に用いられる手法の一種である。MDでは主にポテンシャルエネルギーの最小化の際に用いられるが、他にも機械学習の損失関数の最小化などにも使われている。
 関数の最小値を探索するにあたって最急降下法がとる手法はシンプルで、グラフ上のある点からグラフが形成する坂に従って、極小値(すなわち坂の一番下)に至るまで滑り降りていくという手法である。主な手順は4つの段階に分けられる。

1. 開始地点を決める。
2. 勾配が最も急峻な方向を計算する。
3. 勾配が最も急峻な方向に向かって進む。
4. 手順2と手順3を繰り返して極小値を見つける。

[![最急降下法の概略](https://resources.zero2one.jp/2022/05/ai_exp_169-1024x576.jpeg)](https://zero2one.jp/ai-word/gradient-descent-method/)

 このように手順を分けて書いてしまえば簡単そうに見えるが、本文で述べたようにステップサイズを決めるための情報が少ないため非効率的な探索になりがちであったり、極小値に入ったら抜け出せないため最小値を必ずしも発見できるとは限らないという問題がある。また、目的関数の形状によっては勾配の方向が極小値に向かっておらず、遠回りをせざるを得なくなる場合もある。また、手順3の後の勾配計算やパラメーターを更新する際に、全データを用いて計算を行うため計算時間が長くなるという問題もあり、この問題を解決した手法が確率的勾配降下法(stochastic gradient descent、SGD)と呼ばれる手法もある。

 [![最急降下法の問題点](https://resources.zero2one.jp/2022/12/612f43071a2a0f44423b8bcb86c93e1a-1024x576.jpg)](https://zero2one.jp/ai-word/problems-in-gradient-descent-methods/)

 これらの問題を解決するために他にもいくつかの派生手法が考案されている(モメンタム、AdaGradなど)。この手法は機械学習の分野において損失関数の最小化によく使われている手法で、目的関数が各データの関数の和で表される際に用いられる。(機械学習でよく使われる理由としては、機械学習における損失関数が各データの誤差の和(最小二乗法)で表されるためこちらの方がより効率的に計算を行えることが多い。)SGDでは手順2と手順3の反復において全データではなく1つ、あるいは数個のデータのみを用いて目的関数の誤差や次に使うパラメーターを計算するという操作を繰り返すことで全データ分行う。これによって1回にかかる計算が短縮され、反復計算の信頼性が落ちる部分は反復回数で補っている。また、ランダムなデータで反復して探索するため局所解に陥ってしまった際に抜け出せるというメリットもある。

 最急降下法の背景にある数学は比較的簡単で、目的関数を$f(x)$、各ステップにおける地点を$x_0, x_1, ...$とした際に、
$$x_{k+1}=x_k-\alpha \nabla f(x_k) \tag{5}$$
と表される。ここで$\nabla$は多変数関数$f(x_1, x_2, ... , x_n)$に対して
$$\nabla f(x)=(\frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, ... , \frac{\partial f}{\partial x_n}) \tag{6}$$
とする演算子で、要するには各成分における1階偏微分、すなわち成分ごとに微分をする(=勾配を計算する)ものである。また、$\alpha$は勾配の情報を元にして進む距離を決めるスカラーの係数で、変化率と呼ばれている。
変化率の決め方やどの程度の指標で収束というかは各手法や実装によって異なるものの、式($5$)の大まかな気持ちを要約すると、次のステップでは勾配で下る向き($\nabla f(x)$の向き)に少しだけ($\alpha$の重みをつけた分だけ)進んでから同じことをしてくださいと言っており、極小値(すなわち$\nabla f(x)=0$)となった際には次のステップ以降は位置が変わらない(収束する)ためゴールとするということになる。